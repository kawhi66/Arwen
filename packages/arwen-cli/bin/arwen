#!/usr/bin/env node

function requireRelativeModule(name) {
    return require(require.resolve(`${name}`, {
        paths: [
            process.cwd()
        ]
    }))
}

const fs = require('fs-extra')
const yargs = require('yargs')

const {
    ErrorHandler
} = require('@arwen/arwen-utils')

yargs
    .command('$0', false, yargs => {}, argv => {
        // TODO: show some interesting stuff
        console.log('hello arwen')
    })
    .command(require('../create'))
    .command(['serve', 'start', 'dev'], 'launch the server in development mode', yargs => {
        return yargs
            .option('h', {
                alias: 'host',
                default: 'localhost',
                description: 'specify host',
                type: 'string'
            })
            .option('p', {
                alias: 'port',
                default: '3000',
                description: 'specify port',
                type: 'string'
            })
    }, argv => {
        const Service = requireRelativeModule(`@arwen/${argv.type}-scripts`)
        new Service(argv).run('serve')
    }, [verifyPkgConfig])
    .command(['build', 'release'], 'compile and build', yargs => {
        const {
            name,
            version
        } = fs.readJsonSync('./package.json')

        return yargs
            .option('debug', {
                default: false,
                description: 'turn on the source map in production',
                type: 'boolean'
            })
            .option('package-name', {
                default: `${name}.${version}.${new Date().getTime()}`,
                description: 'specify zip package name',
                type: 'string'
            })
            .option('p', {
                alias: 'pack',
                default: false,
                description: 'to zip file',
                type: 'boolean'
            })
    }, argv => {
        const Service = requireRelativeModule(`@arwen/${argv.type}-scripts`)
        new Service(argv).run('build')
    }, [verifyPkgConfig])
    // .middleware(verifyPkgConfig) // global middleware
    .usage('Usage: arwen <command> [options]')
    .example('$0 create demo -t h_ui', 'generate h_ui project')
    .example('$0 serve', 'run the server for development environment')
    .example('$0 build', 'run the build for production environment')
    .epilog('https://kawhi.site')
    .alias('v', 'version')
    .fail((msg, err, yargs) => {
        if (err) {
            throw err
        }
    })
    .detectLocale(false)
    .wrap(120)
    .help()
    .argv

/**
 * @description async middleware to verify if the current work directory is an valid an arwen project
 * @description it should only work for command serve and build
 * @todo if don't exit manually, the process won't be interruptted no matter what does this middleware returns
 * @todo It doesn 't seem logical for a middleware
 */
function verifyPkgConfig(argv) {
    return fs.readJson('./package.json').then(({
        arwen
    }) => {
        if (arwen && arwen.type) {
            return {
                ...arwen,
                ...argv
            }
        } else {
            throw new ErrorHandler('INVALID_ARWEN_TYPE')
        }
    }).catch(err => {
        if (!err.isArwen) {
            err = new ErrorHandler('UNKNOWN_ERROR')
        }
        console.error(`${err.code}: ${err.message}`)
        yargs.exit(1, err)
    })
}
